{"version":3,"sources":["IndexedDbProvider.js","src/Types/StorageProviders/IndexedDB/IndexedDBConverter.js","src/Types/StorageProviders/IndexedDB/IndexedDBStorageProvider.js","src/Types/StorageProviders/IndexedDB/index.js"],"names":["interopDefine","define","amd","deps","callback","f","exports","module","g","window","global","self","this","$data","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"_interopRequireDefault","obj","__esModule","default","_core","_core2","IndexedDBConverter","fromDb","$data.Byte","Container","proxyConverter","$data.SByte","$data.Decimal","$data.Float","$data.Int16","$data.Int64","$data.Integer","$data.Int32","$data.Number","$data.Date","$data.DateTimeOffset","$data.Time","$data.String","$data.Boolean","$data.Blob","b","convertTo","Blob","$data.Array","arr","undefined","Array","$data.Object","$data.Guid","parseGuid","toString","$data.GeographyPoint","GeographyPoint","$data.GeographyLineString","GeographyLineString","$data.GeographyPolygon","GeographyPolygon","$data.GeographyMultiPoint","GeographyMultiPoint","$data.GeographyMultiLineString","GeographyMultiLineString","$data.GeographyMultiPolygon","GeographyMultiPolygon","$data.GeographyCollection","GeographyCollection","$data.GeometryPoint","GeometryPoint","$data.GeometryLineString","GeometryLineString","$data.GeometryPolygon","GeometryPolygon","$data.GeometryMultiPoint","GeometryMultiPoint","$data.GeometryMultiLineString","GeometryMultiLineString","$data.GeometryMultiPolygon","GeometryMultiPolygon","$data.GeometryCollection","GeometryCollection","toDb","JSON","parse","stringify","jaydata/core",2,"_typeof","Symbol","iterator","constructor","Class","StorageProviderBase","cfg","ctxInstance","indexedDB","__global","webkitIndexedDB","mozIndexedDB","msIndexedDB","IDBRequest","webkitIDBRequest","mozIDBRequest","msIDBRequest","IDBTransaction","webkitIDBTransaction","mozIDBTransaction","msIDBTransaction","IDBTransactionType","READ_ONLY","READ_WRITE","VERSIONCHANGE","IDBKeyRange","webkitIDBKeyRange","mozIDBKeyRange","msIDBKeyRange","IDBDatabaseException","webkitIDBDatabaseException","mozIDBDatabaseException","msIDBDatabaseException","IDBOpenDBRequest","webkitIDBOpenDBRequest","mozIDBOpenDBRequest","msIDBOpenDBRequest","newVersionAPI","IDBFactory","prototype","deleteDatabase","sequenceStore","SqlCommands","context","providerConfiguration","typeSystem","extend","databaseName","defaults","defaultDatabaseName","version","dbCreation","storageProviders","DbCreationType","DropTableIfChanged","memoryOperations","_setupExtensionMethods","originalContext","getType","supportedBinaryOperators","value","equal","mapTo","dataType","Boolean","notEqual","equalTyped","notEqualTyped","greaterThan","greaterThanOrEqual","lessThan","lessThenOrEqual","or","and","supportedSetOperations","toArray","forEach","enumerable","writable","supportedFieldOperations","supportedUnaryOperators","idbRequest","idbTran","idbOpenDBRequest","setCallbacks","callbackSettings","Guard","raise","Exception","supportedDataTypes","Integer","Number","Date","String","Object","Guid","Byte","SByte","Decimal","Float","Int16","Int32","Int64","Time","DateTimeOffset","fieldConverter","supportedAutoincrementKeys","createGuid","_getObjectStoreDefinition","setDefinition","contextStore","storeName","TableName","keyFields","PhysicalType","memberDefinitions","getKeyProperties","error","name","some","memDef","computed","typeName","resolveName","type","console","log","_getObjectStoreDefinitions","objectStoreDefinitions","_storageModel","objectStoreDefinition","push","_oldCreateDB","setVersionTran","definitions","onready","db","onversionchange","event","target","close","_createDB","oncomplete","dropIfExists","objectStoreNames","contains","deleteObjectStore","storeDef","settings","keyPath","autoIncrement","key","createObjectStore","_hasDbChanges","dropTabes","isOriginal","onupgradeneeded","result","hasTableChanges","DropAllExistingTables","initializeStore","callBack","createCallbackSetting","initializeMemoryStore","success","open","onsuccess","setVersion","parseInt","onerror","arguments","onblocked","onabort","operationProvider","onReady","storageProvider","_initializeStore","initDb","ret","newSequences","createStore","osParam","keySettings","_getKeySettings","openCallbacks","store","transaction","objectStore","clear","item","versionRequest","evt","executeQuery","query","entitySet","getEntitySetFromElementType","defaultType","tableName","dataSource","rawDataList","expression","nodeType","Expressions","ExpressionType","Count","cnt","modelBinderCompiler","createModelBinderConfigCompiler","Visit","openCursor","cursor","count","keys","getPublicMappedProperties","saveChanges","changedItems","saveNextIndependentBlock","independentBlocks","KeySettingsCache","cache","getSettingsForItem","data","fullName","hasOwnProperty","getStorageModel","currentBlock","shift","storesObj","convertedItems","map","physicalData","elementType","keyValue","inverseProperty","concurrencyMode","entityState","EntityState","Added","changedProperties","def","stores","tran","errorCode","ABORT_ERR","ksCache","itemKeys","cursorAction","action","only","ex","abort","add","Deleted","Modified","update","Unchanged","buildIndependentBlocks","_compile","sqlText","createIndexedDBCompiler","compile","isSupported","get","set","indexedDb","IndexedDBStorageProvider","registerProvider",3,"defineProperty","_IndexedDBConverter","_IndexedDBStorageProvider","./IndexedDBConverter.js","./IndexedDBStorageProvider.js"],"mappings":"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","file":"IndexedDbProvider.min.js","sourcesContent":["﻿// JayData 1.5.0 CTP\r\n// Dual licensed under MIT and GPL v2\r\n// Copyright JayStack Technologies (http://jaydata.org/licensing)\r\n//\r\n// JayData is a standards-based, cross-platform Javascript library and a set of\r\n// practices to access and manipulate data from various online and offline sources.\r\n//\r\n// Credits:\r\n//     Hajnalka Battancs, Dániel József, János Roden, László Horváth, Péter Nochta\r\n//     Péter Zentai, Róbert Bónay, Szabolcs Czinege, Viktor Borza, Viktor Lázár,\r\n//     Zoltán Gyebrovszki, Gábor Dolla\r\n//\r\n// More info: http://jaydata.org\r\n(function(){\r\n\tvar interopDefine;\r\n\tif (typeof define != 'function' || (typeof define == 'function' && !define.amd)){\r\n\t\tinteropDefine = function(deps, callback){\r\n\t\t\tcallback();\r\n\t\t};\r\n\t}else interopDefine = define;\r\n\r\n\tinteropDefine(['jaydata'], function(){\r\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.$data = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar _core = require('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.IndexedDBConverter = {\n    fromDb: {\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Container.convertTo(b, _core2.default.Blob) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            if (arr === undefined) {\n                return new _core2.default.Array();\n            }return arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? _core2.default.parseGuid(g).toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyPoint(g);\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyLineString(g);\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyPolygon(g);\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPoint(g);\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiLineString(g);\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeographyMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return new _core2.default.GeographyCollection(g);\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryPoint(g);\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryLineString(g);\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryPolygon(g);\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPoint(g);\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiLineString(g);\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return new _core2.default.GeometryMultiPolygon(g);\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return new _core2.default.GeometryCollection(g);\n            }return g;\n        }\n    },\n    toDb: {\n        '$data.Byte': _core2.default.Container.proxyConverter,\n        '$data.SByte': _core2.default.Container.proxyConverter,\n        '$data.Decimal': _core2.default.Container.proxyConverter,\n        '$data.Float': _core2.default.Container.proxyConverter,\n        '$data.Int16': _core2.default.Container.proxyConverter,\n        '$data.Int64': _core2.default.Container.proxyConverter,\n        '$data.Integer': _core2.default.Container.proxyConverter,\n        '$data.Int32': _core2.default.Container.proxyConverter,\n        '$data.Number': _core2.default.Container.proxyConverter,\n        '$data.Date': _core2.default.Container.proxyConverter,\n        '$data.DateTimeOffset': _core2.default.Container.proxyConverter,\n        '$data.Time': _core2.default.Container.proxyConverter,\n        '$data.String': _core2.default.Container.proxyConverter,\n        '$data.Boolean': _core2.default.Container.proxyConverter,\n        '$data.Blob': function $dataBlob(b) {\n            return b ? _core2.default.Blob.toString(b) : b;\n        },\n        '$data.Array': function $dataArray(arr) {\n            return arr ? JSON.parse(JSON.stringify(arr)) : arr;\n        },\n        '$data.Object': _core2.default.Container.proxyConverter,\n        \"$data.Guid\": function $dataGuid(g) {\n            return g ? g.toString() : g;\n        },\n        '$data.GeographyPoint': function $dataGeographyPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyLineString': function $dataGeographyLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyPolygon': function $dataGeographyPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPoint': function $dataGeographyMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiLineString': function $dataGeographyMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyMultiPolygon': function $dataGeographyMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeographyCollection': function $dataGeographyCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPoint': function $dataGeometryPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryLineString': function $dataGeometryLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryPolygon': function $dataGeometryPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPoint': function $dataGeometryMultiPoint(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiLineString': function $dataGeometryMultiLineString(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryMultiPolygon': function $dataGeometryMultiPolygon(g) {\n            if (g) {\n                return g;\n            }return g;\n        },\n        '$data.GeometryCollection': function $dataGeometryCollection(g) {\n            if (g) {\n                return g;\n            }return g;\n        }\n    }\n};\n\n},{\"jaydata/core\":\"jaydata/core\"}],2:[function(require,module,exports){\n'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _core = require('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_core2.default.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', _core2.default.StorageProviderBase, null, {\n    constructor: function constructor(cfg, ctxInstance) {\n        // mapping IndexedDB types to browser invariant name\n        this.indexedDB = _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB;\n        this.IDBRequest = _core2.default.__global.IDBRequest || _core2.default.__global.webkitIDBRequest || _core2.default.__global.mozIDBRequest || _core2.default.__global.msIDBRequest;\n        this.IDBTransaction = _core2.default.__global.IDBTransaction || _core2.default.__global.webkitIDBTransaction || _core2.default.__global.mozIDBTransaction || _core2.default.__global.msIDBTransaction;\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" };\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY;\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE;\n        }\n\n        this.IDBKeyRange = _core2.default.__global.IDBKeyRange || _core2.default.__global.webkitIDBKeyRange || _core2.default.__global.mozIDBKeyRange || _core2.default.__global.msIDBKeyRange;\n        this.IDBDatabaseException = _core2.default.__global.IDBDatabaseException || _core2.default.__global.webkitIDBDatabaseException || _core2.default.__global.mozIDBDatabaseException || _core2.default.__global.msIDBDatabaseException;\n        this.IDBOpenDBRequest = _core2.default.__global.IDBOpenDBRequest || _core2.default.__global.webkitIDBOpenDBRequest || _core2.default.__global.mozIDBOpenDBRequest || _core2.default.__global.msIDBOpenDBRequest;\n        this.newVersionAPI = !!(_core2.default.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\n        this.sequenceStore = '__jayData_sequence';\n        this.SqlCommands = [];\n        this.context = {};\n        this.providerConfiguration = _core2.default.typeSystem.extend({\n            databaseName: _core2.default.defaults.defaultDatabaseName,\n            version: 1,\n            dbCreation: _core2.default.storageProviders.DbCreationType.DropTableIfChanged,\n            memoryOperations: true\n        }, cfg);\n        this._setupExtensionMethods();\n\n        if (ctxInstance) this.originalContext = ctxInstance.getType();\n    },\n    supportedBinaryOperators: {\n        value: {\n            equal: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqual: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            equalTyped: { mapTo: ' == ', dataType: _core2.default.Boolean },\n            notEqualTyped: { mapTo: ' != ', dataType: _core2.default.Boolean },\n            greaterThan: { mapTo: ' > ', dataType: _core2.default.Boolean },\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: _core2.default.Boolean },\n\n            lessThan: { mapTo: ' < ', dataType: _core2.default.Boolean },\n            lessThenOrEqual: { mapTo: ' <= ', dataType: _core2.default.Boolean },\n            or: { mapTo: ' || ', dataType: _core2.default.Boolean },\n            and: { mapTo: ' && ', dataType: _core2.default.Boolean }\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\n        }\n    },\n    supportedSetOperations: {\n        value: {\n            length: {},\n            toArray: {},\n            forEach: {}\n        },\n        enumerable: true,\n        writable: true\n    },\n    supportedFieldOperations: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    supportedUnaryOperators: {\n        value: {},\n        enumerable: true,\n        writable: true\n    },\n    _setupExtensionMethods: function _setupExtensionMethods() {\n        /// <summary>\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\n        /// </summary>\n        var self = this;\n        var idbRequest = this.IDBRequest;\n        var idbTran = this.IDBTransaction;\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\n        var setCallbacks = function setCallbacks(callbackSettings) {\n            /// <summary>\n            /// Sets the callbacks on the object.\n            /// </summary>\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\n            if ((typeof callbackSettings === 'undefined' ? 'undefined' : _typeof(callbackSettings)) !== 'object') _core.Guard.raise(new _core.Exception('Invalid callbackSettings', null, callbackSettings));\n            for (var i in callbackSettings) {\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function') continue;\n                this[i] = callbackSettings[i];\n            }\n\n            //if (this.readyState == self.IDBRequest.DONE)\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\n            return this;\n        };\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function') idbRequest.prototype.setCallbacks = setCallbacks;\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function') idbTran.prototype.setCallbacks = setCallbacks;\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function') idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\n    },\n    supportedDataTypes: {\n        value: [_core2.default.Integer, _core2.default.Number, _core2.default.Date, _core2.default.String, _core2.default.Boolean, _core2.default.Blob, _core2.default.Array, _core2.default.Object, _core2.default.Guid, _core2.default.GeographyPoint, _core2.default.GeographyLineString, _core2.default.GeographyPolygon, _core2.default.GeographyMultiPoint, _core2.default.GeographyMultiLineString, _core2.default.GeographyMultiPolygon, _core2.default.GeographyCollection, _core2.default.GeometryPoint, _core2.default.GeometryLineString, _core2.default.GeometryPolygon, _core2.default.GeometryMultiPoint, _core2.default.GeometryMultiLineString, _core2.default.GeometryMultiPolygon, _core2.default.GeometryCollection, _core2.default.Byte, _core2.default.SByte, _core2.default.Decimal, _core2.default.Float, _core2.default.Int16, _core2.default.Int32, _core2.default.Int64, _core2.default.Time, _core2.default.DateTimeOffset],\n        writable: false\n    },\n    fieldConverter: { value: _core2.default.IndexedDBConverter },\n\n    supportedAutoincrementKeys: {\n        value: {\n            '$data.Integer': true,\n            '$data.Int32': true,\n            '$data.Guid': function $dataGuid() {\n                return _core2.default.createGuid();\n            }\n        }\n    },\n\n    _getObjectStoreDefinition: function _getObjectStoreDefinition(setDefinition) {\n        var contextStore = {\n            storeName: setDefinition.TableName\n        };\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\n\n        if (0 == keyFields.length) {\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\n            error.name = \"KeyNotFoundError\";\n            throw error;\n        }\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\n        //var keyField = keyFields[0];\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n              if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\n\n        if (keyFields.length > 2 && keyFields.some(function (memDef) {\n            return memDef.computed;\n        })) {\n            _core.Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\n        }\n\n        for (var i = 0; i < keyFields.length; i++) {\n            var typeName = _core.Container.resolveName(keyFields[i].type);\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\n            }\n        }\n\n        contextStore.keyFields = keyFields;\n        return contextStore;\n    },\n\n    _getObjectStoreDefinitions: function _getObjectStoreDefinitions() {\n        var objectStoreDefinitions = [];\n        var self = this;\n        self.context._storageModel.forEach(function (memDef) {\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\n            objectStoreDefinitions.push(objectStoreDefinition);\n        });\n        return objectStoreDefinitions;\n    },\n\n    _oldCreateDB: function _oldCreateDB(setVersionTran, definitions, onready) {\n        var self = this;\n        setVersionTran.db.onversionchange = function (event) {\n            return event.target.close();\n        };\n\n        self._createDB(setVersionTran.db, definitions);\n        setVersionTran.oncomplete = onready;\n    },\n    _createDB: function _createDB(db, definitions) {\n        for (var i = 0; i < definitions.length; i++) {\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\n                db.deleteObjectStore(definitions[i].storeName);\n            }\n        }\n\n        for (var i = 0; i < definitions.length; i++) {\n            var storeDef = definitions[i];\n\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\n                var settings = {};\n                if (storeDef.keyFields.length == 1) {\n                    settings = {\n                        keyPath: storeDef.keyFields[0].name\n                        //autoIncrement: storeDef.keyFields[0].computed\n                    };\n                    var typeName = _core.Container.resolveName(storeDef.keyFields[0].type);\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\n                } else {\n                    settings.key = [];\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\n                        settings.key.push(storeDef.keyFields[i].name);\n                    }\n                }\n                db.createObjectStore(storeDef.storeName, settings);\n            }\n        }\n    },\n    _hasDbChanges: function _hasDbChanges(db, definitions, dropTabes) {\n        var isOriginal = true;\n        for (var i = 0; i < definitions.length; i++) {\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\n\n            if (dropTabes) {\n                definitions[i].dropIfExists = true;\n                isOriginal = false;\n            }\n        }\n\n        return !isOriginal;\n    },\n    onupgradeneeded: function onupgradeneeded(objectStoreDefinitions) {\n        var self = this;\n        return function (e) {\n            var db = e.target.result;\n            db.onversionchange = function (event) {\n                return event.target.close();\n            };\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n            if (hasTableChanges) self._createDB(db, objectStoreDefinitions);\n        };\n    },\n\n    initializeStore: function initializeStore(callBack) {\n        callBack = _core2.default.typeSystem.createCallbackSetting(callBack);\n        var self = this;\n\n        this.initializeMemoryStore({\n            success: function success() {\n                var objectStoreDefinitions;\n                try {\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\n                } catch (e) {\n                    console.log(objectStoreDefinitions);\n                    callBack.error(e);\n                    return;\n                }\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\n                    onsuccess: function onsuccess(e) {\n                        var db = e.target.result;\n                        db.onversionchange = function (event) {\n                            return event.target.close();\n                        };\n\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == _core2.default.storageProviders.DbCreationType.DropAllExistingTables);\n                        //oldAPI\n                        if (db.setVersion) {\n                            if (db.version === \"\" || hasTableChanges) {\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\n                                    onsuccess: function onsuccess(e) {\n                                        var db = e.target.result;\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\n                                            self.db = e.target.db;\n                                            callBack.success(self.context);\n                                        });\n                                    },\n                                    onerror: function onerror() {\n                                        var v = arguments;\n                                    },\n                                    onblocked: function onblocked() {\n                                        var v = arguments;\n                                    }\n                                });\n                                return;\n                            };\n                        } else if (hasTableChanges) {\n                            //newVersionAPI\n                            db.close();\n                            var version = parseInt(db.version) + 1;\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\n                                onsuccess: function onsuccess(e) {\n                                    self.db = e.target.result;\n                                    callBack.success(self.context);\n                                },\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                                onerror: callBack.error,\n                                onabort: callBack.error,\n                                onblocked: callBack.error\n                            });\n                            return;\n                        }\n\n                        self.db = db;\n                        callBack.success(self.context);\n                    },\n                    //newVersionAPI\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\n                    onerror: callBack.error,\n                    onabort: callBack.error,\n                    onblocked: callBack.error\n                });\n            },\n            error: callBack.error\n        });\n    },\n    initializeMemoryStore: function initializeMemoryStore(callBack) {\n        callBack = _core2.default.typeSystem.createCallbackSetting(callBack);\n        var self = this;\n\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\n            self.operationProvider.onReady({\n                success: function success() {\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\n                    callBack.success();\n                },\n                error: callBack.error\n            });\n        } else {\n            callBack.success();\n        }\n    },\n\n    _initializeStore: function _initializeStore(callBack) {\n        callBack = _core2.default.typeSystem.createCallbackSetting(callBack);\n        var self = this;\n\n        var initDb = function initDb(db) {\n            db.onversionchange = function (event) {\n                var ret = event.target.close();\n                return ret;\n            };\n            var newSequences = [];\n            self.context._storageModel.forEach(function (memDef) {\n                function createStore() {\n                    /// <summary>\n                    /// Creates a store for 'memDef'\n                    /// </summary>\n                    var osParam = {};\n                    var keySettings = self._getKeySettings(memDef);\n                    if (self.newVersionAPI) {\n                        if (keySettings.autoIncrement) newSequences.push(memDef.TableName);\n                    } else {\n                        osParam.autoIncrement = keySettings.autoIncrement;\n                    }\n                    if (keySettings.keyPath !== undefined) osParam.keyPath = keySettings.keyPath;\n                    db.createObjectStore(memDef.TableName, osParam);\n                }\n                if (db.objectStoreNames.contains(memDef.TableName)) {\n                    // ObjectStore already present.\n                    if (self.providerConfiguration.dbCreation === _core2.default.storageProviders.DbCreationType.DropAllExistingTables) {\n                        // Force drop and recreate object store\n                        db.deleteObjectStore(memDef.TableName);\n                        createStore();\n                    }\n                } else {\n                    // Store does not exists yet, we need to create it\n                    createStore();\n                }\n            });\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\n                // Sequence store does not exists yet, we create it\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\n                newSequences = [];\n            }\n            return newSequences;\n        };\n        var newSequences = null;\n        // Creating openCallbacks settings for both type of db.open() method\n        var openCallbacks = {\n            onupgradeneeded: function onupgradeneeded(event) {\n                newSequences = initDb(event.target.result);\n            },\n            onerror: callBack.error,\n            onblocked: callBack.error,\n            onsuccess: function onsuccess(event) {\n                self.db = event.target.result;\n                self.db.onversionchange = function (event) {\n                    event.target.close();\n                };\n                if (self.newVersionAPI) {\n                    if (newSequences && newSequences.length > 0) {\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\n                            onerror: callBack.error,\n                            oncomplete: function oncomplete() {\n                                callBack.success(self.context);\n                            }\n                        }).objectStore(self.sequenceStore);\n                        switch (self.providerConfiguration.dbCreation) {\n                            case _core2.default.storageProviders.DbCreationType.DropAllExistingTables:\n                            case _core2.default.storageProviders.DbCreationType.DropTableIfChanged:\n                                // Clearing all data\n                                store.clear();\n                                break;\n                            default:\n                                // Removing data for newly created stores, if they previously existed\n                                newSequences.forEach(function (item) {\n                                    store['delete'](item);\n                                });\n                                break;\n                        }\n                    }\n                    callBack.success(self.context);\n                } else {\n                    // Calling setVersion on webkit\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\n                        onerror: callBack.error,\n                        onblocked: callBack.error,\n                        onsuccess: function onsuccess(event) {\n                            initDb(self.db);\n                            versionRequest.result.oncomplete = function (evt) {\n                                callBack.success(self.context);\n                            };\n                        }\n                    });\n                }\n            }\n        };\n        // For Firefox we need to pass the version here\n        if (self.newVersionAPI) self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);else self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\n    },\n\n    executeQuery: function executeQuery(query, callBack) {\n        callBack = _core2.default.typeSystem.createCallbackSetting(callBack);\n        var self = this;\n\n        //var compiledQuery = self._compile(query);\n\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\n            onerror: callBack.error,\n            onabort: callBack.error,\n            oncomplete: function oncomplete(event) {\n                if (self.operationProvider) {\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\n                    self.operationProvider.storageProvider.executeQuery(query, {\n                        success: function success(query) {\n                            if (query.expression.nodeType === _core2.default.Expressions.ExpressionType.Count) {\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\n                            }\n                            callBack.success(query);\n                        },\n                        error: callBack.error\n                    });\n                } else {\n                    callBack.success(query);\n                }\n            }\n        }).objectStore(entitySet.tableName);\n        var modelBinderCompiler = _core.Container.createModelBinderConfigCompiler(query, []);\n        modelBinderCompiler.Visit(query.expression);\n\n        if (self.operationProvider) {\n            store.openCursor().onsuccess = function (event) {\n                // We currently support only toArray() so let's just dump all data\n                var cursor = event.target.result;\n                if (cursor) {\n                    var value = cursor.value;\n                    query.rawDataList.push(cursor.value);\n                    cursor['continue']();\n                }\n            };\n        } else {\n            switch (query.expression.nodeType) {\n                case _core2.default.Expressions.ExpressionType.Count:\n                    store.count().onsuccess = function (event) {\n                        var count = event.target.result;\n                        query.rawDataList.push({ cnt: count });\n                    };\n                    break;\n                default:\n                    store.openCursor().onsuccess = function (event) {\n                        // We currently support only toArray() so let's just dump all data\n                        var cursor = event.target.result;\n                        if (cursor) {\n                            var value = cursor.value;\n                            query.rawDataList.push(cursor.value);\n                            cursor['continue']();\n                        }\n                    };\n                    break;\n            }\n        };\n    },\n    _getKeySettings: function _getKeySettings(memDef) {\n        /// <summary>\n        /// Gets key settings for item type's member definition\n        /// </summary>\n        /// <param name=\"memDef\">memDef of item</param>\n        /// <returns>KeySettings object</returns>\n        var self = this;\n        var settings = { autoIncrement: false };\n        var keys = [];\n        memDef.PhysicalType.memberDefinitions.getPublicMappedProperties().forEach(function (item) {\n            if (item.key) {\n                // We found a key\n                keys.push(item.name);\n            }\n            if (item.computed) {\n                // AutoIncrement field, must be key\n                if (!item.key) _core.Guard.raise(new _core.Exception('Only key field can be a computed field!'));\n\n                var typeName = _core.Container.resolveName(item.type);\n                if (self.supportedAutoincrementKeys[typeName] === true) {\n                    settings.autoIncrement = true;\n                }\n            }\n        });\n        if (keys.length > 1) {\n            if (settings.autoIncrement) _core.Guard.raise(new _core.Exception('Auto increment is only valid for a single key!'));\n            // Setting key fields (composite key)\n            settings.keys = keys;\n        } else if (keys.length == 1) {\n            // Simple key\n            settings.keyPath = keys[0];\n        } else {\n            _core.Guard.raise(new _core.Exception('No valid key found!'));\n        }\n        return settings;\n    },\n    saveChanges: function saveChanges(callBack, changedItems) {\n        var self = this;\n        // Building independent blocks and processing them sequentially\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\n        function saveNextIndependentBlock() {\n            /// <summary>\n            /// Saves the next independent block\n            /// </summary>\n            if (independentBlocks.length === 0) {\n                // No more blocks left, calling success callback\n                callBack.success();\n            } else {\n                var KeySettingsCache = function KeySettingsCache() {\n                    /// <summary>\n                    /// Simple cache for key settings of types\n                    /// </summary>\n                    var cache = {};\n                    this.getSettingsForItem = function (item) {\n                        var typeName = item.data.getType().fullName;\n                        if (!cache.hasOwnProperty(typeName)) {\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\n                        }\n                        return cache[typeName];\n                    };\n                };\n\n                // 'Popping' next block\n                var currentBlock = independentBlocks.shift();\n                // Collecting stores of items for transaction initialize\n                var storesObj = {};\n                // Generating physicalData\n                var convertedItems = currentBlock.map(function (item) {\n                    storesObj[item.entitySet.tableName] = true;\n                    item.physicalData = {};\n                    item.entitySet.elementType.memberDefinitions.getPublicMappedProperties().forEach(function (memDef) {\n                        var typeName = _core.Container.resolveName(memDef.type);\n                        if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\n                            if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\n                                var keyValue = self.supportedAutoincrementKeys[typeName]();\n                                item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\n                            } else {\n                                // Autogenerated fields for new items should not be present in the physicalData\n                                return;\n                            }\n                        }\n                        if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === _core2.default.EntityState.Added || item.data.changedProperties && item.data.changedProperties.some(function (def) {\n                            return def.name === memDef.name;\n                        }))) {\n                            if (self.fieldConverter.toDb[typeName]) {\n                                item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\n                            } else {\n                                var value = item.data[memDef.name];\n                                if (value !== undefined) {\n                                    value = JSON.parse(JSON.stringify(value));\n                                }\n                                item.physicalData[memDef.name] = value;\n                            }\n                        }\n                    });\n                    return item;\n                });\n                var stores = [];\n                for (var i in storesObj) {\n                    stores.push(i);\n                }\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\n                    onerror: function onerror(event) {\n                        // Only call the error callback when it's not because of an abort\n                        // aborted cases should call the error callback there\n                        if (!event.target || !self.IDBDatabaseException || event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR) callBack.error(event);\n                    },\n                    oncomplete: function oncomplete(event) {\n                        // Moving to next block\n                        saveNextIndependentBlock();\n                    }\n                });\n\n                var ksCache = new KeySettingsCache();\n                convertedItems.forEach(function (item) {\n                    // Getting store and keysettings for the current item\n                    var store = tran.objectStore(item.entitySet.tableName);\n                    var keySettings = ksCache.getSettingsForItem(item);\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) {\n                        return item.physicalData[key];\n                    }) || null;\n                    try {\n                        var cursorAction = function cursorAction(action) {\n                            /// <summary>\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\n                            /// </summary>\n                            /// <param name=\"action\">Action to call on the item</param>\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\n                            var data = item.physicalData;\n                            store.openCursor(self.IDBKeyRange.only(key)).onsuccess = function (event) {\n                                try {\n                                    var cursor = event.target.result;\n                                    if (cursor) action(cursor, key, data);else _core.Guard.raise(new _core.Exception('Object not found', null, item));\n                                } catch (ex) {\n                                    tran.abort();\n                                    callBack.error(ex);\n                                }\n                            };\n                        };\n                        switch (item.data.entityState) {\n                            case _core2.default.EntityState.Added:\n                                if (!keySettings.keyPath) {\n                                    // Item needs explicit keys\n                                    store.add(item.physicalData, itemKeys);\n                                } else {\n                                    store.add(item.physicalData).onsuccess = function (event) {\n                                        // Saves the generated key back to the entity\n                                        item.data[keySettings.keyPath] = event.target.result;\n                                    };\n                                }\n                                break;\n                            case _core2.default.EntityState.Deleted:\n                                // Deletes the item\n                                cursorAction(function (cursor) {\n                                    cursor['delete']();\n                                });\n                                break;\n                            case _core2.default.EntityState.Modified:\n                                // Updates the item\n                                cursorAction(function (cursor, key, data) {\n                                    cursor.update(_core2.default.typeSystem.extend(cursor.value, data));\n                                });\n                                break;\n                            case _core2.default.EntityState.Unchanged:\n                                break;\n                            default:\n                                _core.Guard.raise(new _core.Exception('Not supported entity state', null, item));\n                        }\n                    } catch (ex) {\n                        // Abort on exceptions\n                        tran.abort();\n                        callBack.error(ex);\n                    }\n                });\n            }\n        }\n        saveNextIndependentBlock();\n    },\n    _compile: function _compile(query) {\n        var sqlText = _core.Container.createIndexedDBCompiler().compile(query);\n        return sqlText;\n    }\n}, {\n    isSupported: {\n        get: function get() {\n            return _core2.default.__global.indexedDB || _core2.default.__global.webkitIndexedDB || _core2.default.__global.mozIndexedDB || _core2.default.__global.msIndexedDB ? true : false;\n        },\n        set: function set() {}\n    }\n});\n\nif (_core2.default.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported) _core2.default.StorageProviderBase.registerProvider('indexedDb', _core2.default.storageProviders.indexedDb.IndexedDBStorageProvider);\n\n},{\"jaydata/core\":\"jaydata/core\"}],3:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = require('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _IndexedDBConverter = require('./IndexedDBConverter.js');\n\nvar _IndexedDBConverter2 = _interopRequireDefault(_IndexedDBConverter);\n\nvar _IndexedDBStorageProvider = require('./IndexedDBStorageProvider.js');\n\nvar _IndexedDBStorageProvider2 = _interopRequireDefault(_IndexedDBStorageProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n\n},{\"./IndexedDBConverter.js\":1,\"./IndexedDBStorageProvider.js\":2,\"jaydata/core\":\"jaydata/core\"}]},{},[3])(3)\n});\n\n\t});\r\n})();\r\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.IndexedDBConverter = {\r\n    fromDb: {\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function (b) { return b ? $data.Container.convertTo(b, $data.Blob) : b; },\r\n        '$data.Array': function (arr) { if (arr === undefined) { return new $data.Array(); } return arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? $data.parseGuid(g).toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return new $data.GeographyPoint(g); } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return new $data.GeographyLineString(g); } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return new $data.GeographyPolygon(g); } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return new $data.GeographyMultiPoint(g); } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return new $data.GeographyMultiLineString(g); } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return new $data.GeographyMultiPolygon(g); } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return new $data.GeographyCollection(g); } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return new $data.GeometryPoint(g); } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return new $data.GeometryLineString(g); } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return new $data.GeometryPolygon(g); } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return new $data.GeometryMultiPoint(g); } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return new $data.GeometryMultiLineString(g); } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return new $data.GeometryMultiPolygon(g); } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return new $data.GeometryCollection(g); } return g; }\r\n    },\r\n    toDb: {\r\n        '$data.Byte': $data.Container.proxyConverter,\r\n        '$data.SByte': $data.Container.proxyConverter,\r\n        '$data.Decimal': $data.Container.proxyConverter,\r\n        '$data.Float': $data.Container.proxyConverter,\r\n        '$data.Int16': $data.Container.proxyConverter,\r\n        '$data.Int64': $data.Container.proxyConverter,\r\n        '$data.Integer': $data.Container.proxyConverter,\r\n        '$data.Int32': $data.Container.proxyConverter,\r\n        '$data.Number': $data.Container.proxyConverter,\r\n        '$data.Date': $data.Container.proxyConverter,\r\n        '$data.DateTimeOffset': $data.Container.proxyConverter,\r\n        '$data.Time': $data.Container.proxyConverter,\r\n        '$data.String': $data.Container.proxyConverter,\r\n        '$data.Boolean': $data.Container.proxyConverter,\r\n        '$data.Blob': function(b){ return b ? $data.Blob.toString(b) : b; },\r\n        '$data.Array': function (arr) { return arr ? JSON.parse(JSON.stringify(arr)) : arr; },\r\n        '$data.Object': $data.Container.proxyConverter,\r\n        \"$data.Guid\": function (g) { return g ? g.toString() : g; },\r\n        '$data.GeographyPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeographyCollection': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPoint': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiLineString': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryMultiPolygon': function (g) { if (g) { return g; } return g; },\r\n        '$data.GeometryCollection': function (g) { if (g) { return g; } return g; }\r\n    }\r\n};\r\n","import $data, { $C, Guard, Container, Exception, MemberDefinition } from 'jaydata/core';\r\n\r\n$data.Class.define('$data.storageProviders.indexedDb.IndexedDBStorageProvider', $data.StorageProviderBase, null,\r\n{\r\n    constructor: function (cfg, ctxInstance) {\r\n        // mapping IndexedDB types to browser invariant name\r\n        this.indexedDB = $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB;\r\n        this.IDBRequest = $data.__global.IDBRequest || $data.__global.webkitIDBRequest || $data.__global.mozIDBRequest || $data.__global.msIDBRequest;\r\n        this.IDBTransaction = $data.__global.IDBTransaction || $data.__global.webkitIDBTransaction || $data.__global.mozIDBTransaction || $data.__global.msIDBTransaction;\r\n        this.IDBTransactionType = { READ_ONLY: \"readonly\", READ_WRITE: \"readwrite\", VERSIONCHANGE: \"versionchange\" }\r\n        if (typeof this.IDBTransaction.READ_ONLY !== 'undefined' && typeof this.IDBTransaction.READ_WRITE !== 'undefined') {\r\n            this.IDBTransactionType.READ_ONLY = this.IDBTransaction.READ_ONLY\r\n            this.IDBTransactionType.READ_WRITE = this.IDBTransaction.READ_WRITE\r\n        }\r\n\r\n        this.IDBKeyRange = $data.__global.IDBKeyRange || $data.__global.webkitIDBKeyRange || $data.__global.mozIDBKeyRange || $data.__global.msIDBKeyRange;\r\n        this.IDBDatabaseException = $data.__global.IDBDatabaseException || $data.__global.webkitIDBDatabaseException || $data.__global.mozIDBDatabaseException || $data.__global.msIDBDatabaseException;\r\n        this.IDBOpenDBRequest = $data.__global.IDBOpenDBRequest || $data.__global.webkitIDBOpenDBRequest || $data.__global.mozIDBOpenDBRequest || $data.__global.msIDBOpenDBRequest;\r\n        this.newVersionAPI = !!($data.__global.IDBFactory && IDBFactory.prototype.deleteDatabase);\r\n        this.sequenceStore = '__jayData_sequence';\r\n        this.SqlCommands = [];\r\n        this.context = {};\r\n        this.providerConfiguration = $data.typeSystem.extend({\r\n            databaseName: $data.defaults.defaultDatabaseName,\r\n            version: 1,\r\n            dbCreation: $data.storageProviders.DbCreationType.DropTableIfChanged,\r\n            memoryOperations: true\r\n        }, cfg);\r\n        this._setupExtensionMethods();\r\n\r\n        if (ctxInstance)\r\n            this.originalContext = ctxInstance.getType();\r\n    },\r\n    supportedBinaryOperators: {\r\n        value: {\r\n            equal: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqual: { mapTo: ' != ', dataType: $data.Boolean },\r\n            equalTyped: { mapTo: ' == ', dataType: $data.Boolean },\r\n            notEqualTyped: { mapTo: ' != ', dataType: $data.Boolean },\r\n            greaterThan: { mapTo: ' > ', dataType: $data.Boolean },\r\n            greaterThanOrEqual: { mapTo: ' >= ', dataType: $data.Boolean },\r\n\r\n            lessThan: { mapTo: ' < ', dataType: $data.Boolean },\r\n            lessThenOrEqual: { mapTo: ' <= ', dataType: $data.Boolean },\r\n            or: { mapTo: ' || ', dataType: $data.Boolean },\r\n            and: { mapTo: ' && ', dataType: $data.Boolean }\r\n            //'in': { mapTo: ' in ', dataType: $data.Boolean, resolvableType: [$data.Array, $data.Queryable] }\r\n        }\r\n    },\r\n    supportedSetOperations: {\r\n        value: {\r\n            length: {},\r\n            toArray: {},\r\n            forEach: {}\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedFieldOperations: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    supportedUnaryOperators: {\r\n        value: {\r\n        },\r\n        enumerable: true,\r\n        writable: true\r\n    },\r\n    _setupExtensionMethods: function () {\r\n        /// <summary>\r\n        /// Sets the extension method 'setCallback' on IDBRequest, IDBOpenDBRequest, and IDBTransaction types\r\n        /// </summary>\r\n        var self = this;\r\n        var idbRequest = this.IDBRequest;\r\n        var idbTran = this.IDBTransaction;\r\n        var idbOpenDBRequest = this.IDBOpenDBRequest;\r\n        var setCallbacks = function (callbackSettings) {\r\n            /// <summary>\r\n            /// Sets the callbacks on the object.\r\n            /// </summary>\r\n            /// <param name=\"callbackSettings\">Named value pairs of the callbacks</param>\r\n            if (typeof callbackSettings !== 'object')\r\n                Guard.raise(new Exception('Invalid callbackSettings', null, callbackSettings));\r\n            for (var i in callbackSettings) {\r\n                if (typeof this[i] === 'undefined' || typeof callbackSettings[i] !== 'function')\r\n                    continue;\r\n                this[i] = callbackSettings[i];\r\n            }\r\n\r\n            //if (this.readyState == self.IDBRequest.DONE)\r\n            //    console.log('WARNING: request finished before setCallbacks. Do not use breakpoints between creating the request object and finishing the setting of callbacks');\r\n            return this;\r\n        };\r\n        if (idbRequest && typeof idbRequest.prototype.setCallbacks !== 'function')\r\n            idbRequest.prototype.setCallbacks = setCallbacks;\r\n        if (idbTran && typeof idbTran.prototype.setCallbacks !== 'function')\r\n            idbTran.prototype.setCallbacks = setCallbacks;\r\n        if (idbOpenDBRequest && typeof idbOpenDBRequest.prototype.setCallbacks !== 'function')\r\n            idbOpenDBRequest.prototype.setCallbacks = setCallbacks;\r\n    },\r\n    supportedDataTypes: {\r\n        value: [$data.Integer, $data.Number, $data.Date, $data.String, $data.Boolean, $data.Blob, $data.Array, $data.Object, $data.Guid, $data.GeographyPoint,\r\n            $data.GeographyLineString, $data.GeographyPolygon, $data.GeographyMultiPoint, $data.GeographyMultiLineString, $data.GeographyMultiPolygon, $data.GeographyCollection,\r\n            $data.GeometryPoint, $data.GeometryLineString, $data.GeometryPolygon, $data.GeometryMultiPoint, $data.GeometryMultiLineString, $data.GeometryMultiPolygon, $data.GeometryCollection,\r\n            $data.Byte, $data.SByte, $data.Decimal, $data.Float, $data.Int16, $data.Int32, $data.Int64, $data.Time, $data.DateTimeOffset],\r\n        writable: false\r\n    },\r\n    fieldConverter: { value: $data.IndexedDBConverter },\r\n\r\n    supportedAutoincrementKeys: {\r\n        value: {\r\n            '$data.Integer': true,\r\n            '$data.Int32': true,\r\n            '$data.Guid': function () { return $data.createGuid(); }\r\n        }\r\n    },\r\n\r\n    _getObjectStoreDefinition: function (setDefinition) {\r\n        var contextStore = {\r\n            storeName: setDefinition.TableName\r\n        };\r\n        var keyFields = setDefinition.PhysicalType.memberDefinitions.getKeyProperties();\r\n\r\n        if (0 == keyFields.length) {\r\n            var error = new Error(\"Entity must have a key field: \" + contextStore.storeName);\r\n            error.name = \"KeyNotFoundError\";\r\n            throw error;\r\n        }\r\n        /*if (1 != keyFields.length) {\r\n            var error = new Error(\"Entity must have only one key field: \" + contextStore.storeName);\r\n            error.name = \"MultipleKeysNotSupportedError\";\r\n            throw error;\r\n        }*/\r\n        //var keyField = keyFields[0];\r\n        /*for (var i = 0; i < keyFields.length; i++) {\r\n\r\n            if (keyFields[i].computed === true &&\r\n                (\"$data.Integer\" !== Container.resolveName(keyFields[i].type))) {\r\n                var error = new Error(\"Computed key field must be of integer type: \" + contextStore.storeName);\r\n                error.name = \"ComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n            if (keyFields.length > 2 && keyFields[i].computed) {\r\n                var error = new Error(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName);\r\n                error.name = \"MultipleComputedKeyFieldError\";\r\n                throw error;\r\n            }\r\n        }*/\r\n\r\n        if (keyFields.length > 2 && keyFields.some(function (memDef) { return memDef.computed; })) {\r\n            Guard.raise(\"With multiple keys the computed field is not allowed: \" + contextStore.storeName, \"MultipleComputedKeyFieldError\");\r\n        }\r\n\r\n        for (var i = 0; i < keyFields.length; i++) {\r\n            var typeName = Container.resolveName(keyFields[i].type);\r\n            if (keyFields[i].computed && !this.supportedAutoincrementKeys[typeName]) {\r\n                console.log(\"WARRNING! '\" + typeName + \"' not supported as computed Key!\");\r\n            }\r\n        }\r\n\r\n        contextStore.keyFields = keyFields;\r\n        return contextStore;\r\n    },\r\n\r\n    _getObjectStoreDefinitions: function () {\r\n        var objectStoreDefinitions = [];\r\n        var self = this;\r\n        self.context._storageModel.forEach(function (memDef) {\r\n            var objectStoreDefinition = self._getObjectStoreDefinition(memDef);\r\n            objectStoreDefinitions.push(objectStoreDefinition);\r\n        });\r\n        return objectStoreDefinitions;\r\n    },\r\n\r\n    _oldCreateDB: function (setVersionTran, definitions, onready) {\r\n        var self = this;\r\n        setVersionTran.db.onversionchange = function (event) {\r\n            return event.target.close();\r\n        };\r\n\r\n        self._createDB(setVersionTran.db, definitions);\r\n        setVersionTran.oncomplete = onready;\r\n    },\r\n    _createDB: function (db, definitions) {\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            if (definitions[i].dropIfExists && db.objectStoreNames.contains(definitions[i].storeName)) {\r\n                db.deleteObjectStore(definitions[i].storeName);\r\n            }\r\n        }\r\n\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            var storeDef = definitions[i];\r\n\r\n            if (!db.objectStoreNames.contains(storeDef.storeName)) {\r\n                var settings = {};\r\n                if (storeDef.keyFields.length == 1) {\r\n                    settings = {\r\n                        keyPath: storeDef.keyFields[0].name\r\n                        //autoIncrement: storeDef.keyFields[0].computed\r\n                    };\r\n                    var typeName = Container.resolveName(storeDef.keyFields[0].type);\r\n                    settings.autoIncrement = this.supportedAutoincrementKeys[typeName] ? true : false;\r\n                } else {\r\n                    settings.key = [];\r\n                    for (var i = 0; i < storeDef.keyFields.length; i++) {\r\n                        settings.key.push(storeDef.keyFields[i].name);\r\n                    }\r\n                }\r\n                db.createObjectStore(storeDef.storeName, settings);\r\n            }\r\n        }\r\n    },\r\n    _hasDbChanges: function (db, definitions, dropTabes) {\r\n        var isOriginal = true;\r\n        for (var i = 0; i < definitions.length; i++) {\r\n            isOriginal = isOriginal && db.objectStoreNames.contains(definitions[i].storeName);\r\n\r\n            if (dropTabes) {\r\n                definitions[i].dropIfExists = true;\r\n                isOriginal = false;\r\n            }\r\n        }\r\n\r\n        return !isOriginal;\r\n    },\r\n    onupgradeneeded: function (objectStoreDefinitions) {\r\n        var self = this;\r\n        return function (e) {\r\n            var db = e.target.result;\r\n            db.onversionchange = function (event) {\r\n                return event.target.close();\r\n            };\r\n            var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n            if (hasTableChanges)\r\n                self._createDB(db, objectStoreDefinitions);\r\n        }\r\n    },\r\n\r\n    initializeStore: function (callBack) {\r\n        callBack = $data.typeSystem.createCallbackSetting(callBack);\r\n        var self = this;\r\n\r\n        this.initializeMemoryStore({\r\n            success: function () {\r\n                var objectStoreDefinitions;\r\n                try {\r\n                    objectStoreDefinitions = self._getObjectStoreDefinitions();\r\n                } catch (e) {\r\n                    console.log(objectStoreDefinitions);\r\n                    callBack.error(e);\r\n                    return;\r\n                }\r\n                self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks({\r\n                    onsuccess: function (e) {\r\n                        var db = e.target.result;\r\n                        db.onversionchange = function (event) {\r\n                            return event.target.close();\r\n                        };\r\n\r\n                        var hasTableChanges = self._hasDbChanges(db, objectStoreDefinitions, self.providerConfiguration.dbCreation == $data.storageProviders.DbCreationType.DropAllExistingTables);\r\n                        //oldAPI\r\n                        if (db.setVersion) {\r\n                            if (db.version === \"\" || hasTableChanges) {\r\n                                db.setVersion((parseInt(db.version) || 0) + 1).setCallbacks({\r\n                                    onsuccess: function (e) {\r\n                                        var db = e.target.result\r\n                                        self._oldCreateDB(db /*setVerTran*/, objectStoreDefinitions, function (e) {\r\n                                            self.db = e.target.db;\r\n                                            callBack.success(self.context);\r\n                                        });\r\n                                    },\r\n                                    onerror: function () {\r\n                                        var v = arguments;\r\n                                    },\r\n                                    onblocked: function () {\r\n                                        var v = arguments;\r\n                                    }\r\n                                });\r\n                                return;\r\n                            };\r\n                        } else if (hasTableChanges) {\r\n                            //newVersionAPI\r\n                            db.close();\r\n                            var version = parseInt(db.version) + 1;\r\n                            self.indexedDB.open(self.providerConfiguration.databaseName, version).setCallbacks({\r\n                                onsuccess: function (e) {\r\n                                    self.db = e.target.result;\r\n                                    callBack.success(self.context);\r\n                                },\r\n                                onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                                onerror: callBack.error,\r\n                                onabort: callBack.error,\r\n                                onblocked: callBack.error\r\n                            });\r\n                            return;\r\n                        }\r\n\r\n                        self.db = db;\r\n                        callBack.success(self.context);\r\n                    },\r\n                    //newVersionAPI\r\n                    onupgradeneeded: self.onupgradeneeded(objectStoreDefinitions),\r\n                    onerror: callBack.error,\r\n                    onabort: callBack.error,\r\n                    onblocked: callBack.error\r\n                });\r\n            },\r\n            error: callBack.error\r\n        });\r\n    },\r\n    initializeMemoryStore: function (callBack) {\r\n        callBack = $data.typeSystem.createCallbackSetting(callBack);\r\n        var self = this;\r\n\r\n        if (self.originalContext && self.providerConfiguration.memoryOperations) {\r\n            self.operationProvider = new self.originalContext({ name: 'InMemory' });\r\n            self.operationProvider.onReady({\r\n                success: function () {\r\n                    self.supportedBinaryOperators = self.operationProvider.storageProvider.supportedBinaryOperators;\r\n                    self.supportedSetOperations = self.operationProvider.storageProvider.supportedSetOperations;\r\n                    self.supportedFieldOperations = self.operationProvider.storageProvider.supportedFieldOperations;\r\n                    self.supportedUnaryOperators = self.operationProvider.storageProvider.supportedUnaryOperators;\r\n                    callBack.success();\r\n                },\r\n                error: callBack.error\r\n            });\r\n        } else {\r\n            callBack.success();\r\n        }\r\n    },\r\n\r\n    _initializeStore: function (callBack) {\r\n        callBack = $data.typeSystem.createCallbackSetting(callBack);\r\n        var self = this;\r\n\r\n\r\n        var initDb = function (db) {\r\n            db.onversionchange = function (event) {\r\n                var ret = event.target.close();\r\n                return ret;\r\n            };\r\n            var newSequences = [];\r\n            self.context._storageModel.forEach(function (memDef) {\r\n                function createStore() {\r\n                    /// <summary>\r\n                    /// Creates a store for 'memDef'\r\n                    /// </summary>\r\n                    var osParam = {};\r\n                    var keySettings = self._getKeySettings(memDef);\r\n                    if (self.newVersionAPI) {\r\n                        if (keySettings.autoIncrement)\r\n                            newSequences.push(memDef.TableName);\r\n                    } else {\r\n                        osParam.autoIncrement = keySettings.autoIncrement;\r\n                    }\r\n                    if (keySettings.keyPath !== undefined)\r\n                        osParam.keyPath = keySettings.keyPath;\r\n                    db.createObjectStore(memDef.TableName, osParam);\r\n                }\r\n                if (db.objectStoreNames.contains(memDef.TableName)) {\r\n                    // ObjectStore already present.\r\n                    if (self.providerConfiguration.dbCreation === $data.storageProviders.DbCreationType.DropAllExistingTables) {\r\n                        // Force drop and recreate object store\r\n                        db.deleteObjectStore(memDef.TableName);\r\n                        createStore();\r\n                    }\r\n                } else {\r\n                    // Store does not exists yet, we need to create it\r\n                    createStore();\r\n                }\r\n            });\r\n            if (newSequences.length > 0 && !db.objectStoreNames.contains(self.sequenceStore)) {\r\n                // Sequence store does not exists yet, we create it\r\n                db.createObjectStore(self.sequenceStore, { keyPath: 'store' });\r\n                newSequences = [];\r\n            }\r\n            return newSequences;\r\n        }\r\n        var newSequences = null;\r\n        // Creating openCallbacks settings for both type of db.open() method\r\n        var openCallbacks = {\r\n            onupgradeneeded: function (event) {\r\n                newSequences = initDb(event.target.result);\r\n            },\r\n            onerror: callBack.error,\r\n            onblocked: callBack.error,\r\n            onsuccess: function (event) {\r\n                self.db = event.target.result;\r\n                self.db.onversionchange = function (event) {\r\n                    event.target.close();\r\n                }\r\n                if (self.newVersionAPI) {\r\n                    if (newSequences && newSequences.length > 0) {\r\n                        var store = self.db.transaction([self.sequenceStore], self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                            onerror: callBack.error,\r\n                            oncomplete: function () {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }).objectStore(self.sequenceStore);\r\n                        switch (self.providerConfiguration.dbCreation) {\r\n                            case $data.storageProviders.DbCreationType.DropAllExistingTables:\r\n                            case $data.storageProviders.DbCreationType.DropTableIfChanged:\r\n                                // Clearing all data\r\n                                store.clear();\r\n                                break;\r\n                            default:\r\n                                // Removing data for newly created stores, if they previously existed\r\n                                newSequences.forEach(function (item) {\r\n                                    store['delete'](item);\r\n                                });\r\n                                break;\r\n                        }\r\n                    }\r\n                    callBack.success(self.context);\r\n                }\r\n                else {\r\n                    // Calling setVersion on webkit\r\n                    var versionRequest = self.db.setVersion(self.providerConfiguration.version.toString()).setCallbacks({\r\n                        onerror: callBack.error,\r\n                        onblocked: callBack.error,\r\n                        onsuccess: function (event) {\r\n                            initDb(self.db);\r\n                            versionRequest.result.oncomplete = function (evt) {\r\n                                callBack.success(self.context);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        };\r\n        // For Firefox we need to pass the version here\r\n        if (self.newVersionAPI)\r\n            self.indexedDB.open(self.providerConfiguration.databaseName, parseInt(self.providerConfiguration.version, 10)).setCallbacks(openCallbacks);\r\n        else\r\n            self.indexedDB.open(self.providerConfiguration.databaseName).setCallbacks(openCallbacks);\r\n    },\r\n\r\n    executeQuery: function (query, callBack) {\r\n        callBack = $data.typeSystem.createCallbackSetting(callBack);\r\n        var self = this;\r\n\r\n        //var compiledQuery = self._compile(query);\r\n\r\n        // Creating read only transaction for query. Results are passed in transaction's oncomplete event\r\n        var entitySet = query.context.getEntitySetFromElementType(query.defaultType);\r\n        var store = self.db.transaction([entitySet.tableName], self.IDBTransactionType.READ_ONLY).setCallbacks({\r\n            onerror: callBack.error,\r\n            onabort: callBack.error,\r\n            oncomplete: function (event) {\r\n                if (self.operationProvider) {\r\n                    self.operationProvider.storageProvider.dataSource[entitySet.tableName] = query.rawDataList;\r\n                    self.operationProvider.storageProvider.executeQuery(query, {\r\n                        success: function (query) {\r\n                            if (query.expression.nodeType === $data.Expressions.ExpressionType.Count) {\r\n                                query.rawDataList[0] = { cnt: query.rawDataList[0] };\r\n                            }\r\n                            callBack.success(query);\r\n                        },\r\n                        error: callBack.error\r\n                    });\r\n                } else {\r\n                    callBack.success(query);\r\n                }\r\n            }\r\n        }).objectStore(entitySet.tableName);\r\n        var modelBinderCompiler = Container.createModelBinderConfigCompiler(query, []);\r\n        modelBinderCompiler.Visit(query.expression);\r\n\r\n        if (self.operationProvider) {\r\n            store.openCursor().onsuccess = function (event) {\r\n                // We currently support only toArray() so let's just dump all data\r\n                var cursor = event.target.result;\r\n                if (cursor) {\r\n                    var value = cursor.value;\r\n                    query.rawDataList.push(cursor.value);\r\n                    cursor['continue']();\r\n                }\r\n            };\r\n        } else {\r\n            switch (query.expression.nodeType) {\r\n                case $data.Expressions.ExpressionType.Count:\r\n                    store.count().onsuccess = function (event) {\r\n                        var count = event.target.result;\r\n                        query.rawDataList.push({ cnt: count });\r\n                    }\r\n                    break;\r\n                default:\r\n                    store.openCursor().onsuccess = function (event) {\r\n                        // We currently support only toArray() so let's just dump all data\r\n                        var cursor = event.target.result;\r\n                        if (cursor) {\r\n                            var value = cursor.value;\r\n                            query.rawDataList.push(cursor.value);\r\n                            cursor['continue']();\r\n                        }\r\n                    };\r\n                    break;\r\n            }\r\n        };\r\n    },\r\n    _getKeySettings: function (memDef) {\r\n        /// <summary>\r\n        /// Gets key settings for item type's member definition\r\n        /// </summary>\r\n        /// <param name=\"memDef\">memDef of item</param>\r\n        /// <returns>KeySettings object</returns>\r\n        var self = this;\r\n        var settings = { autoIncrement: false };\r\n        var keys = [];\r\n        memDef.PhysicalType.memberDefinitions\r\n            .getPublicMappedProperties().forEach(function (item) {\r\n                if (item.key) {\r\n                    // We found a key\r\n                    keys.push(item.name);\r\n                }\r\n                if (item.computed) {\r\n                    // AutoIncrement field, must be key\r\n                    if (!item.key)\r\n                        Guard.raise(new Exception('Only key field can be a computed field!'));\r\n\r\n                    var typeName = Container.resolveName(item.type);\r\n                    if (self.supportedAutoincrementKeys[typeName] === true) {\r\n                        settings.autoIncrement = true;\r\n                    }\r\n                }\r\n            });\r\n        if (keys.length > 1) {\r\n            if (settings.autoIncrement)\r\n                Guard.raise(new Exception('Auto increment is only valid for a single key!'));\r\n            // Setting key fields (composite key)\r\n            settings.keys = keys;\r\n        } else if (keys.length == 1) {\r\n            // Simple key\r\n            settings.keyPath = keys[0];\r\n        } else {\r\n            Guard.raise(new Exception('No valid key found!'));\r\n        }\r\n        return settings;\r\n    },\r\n    saveChanges: function (callBack, changedItems) {\r\n        var self = this;\r\n        // Building independent blocks and processing them sequentially\r\n        var independentBlocks = self.buildIndependentBlocks(changedItems);\r\n        function saveNextIndependentBlock() {\r\n            /// <summary>\r\n            /// Saves the next independent block\r\n            /// </summary>\r\n            if (independentBlocks.length === 0) {\r\n                // No more blocks left, calling success callback\r\n                callBack.success();\r\n            } else {\r\n                // 'Popping' next block\r\n                var currentBlock = independentBlocks.shift();\r\n                // Collecting stores of items for transaction initialize\r\n                var storesObj = {};\r\n                // Generating physicalData\r\n                var convertedItems = currentBlock.map(function (item) {\r\n                    storesObj[item.entitySet.tableName] = true;\r\n                    item.physicalData = {};\r\n                    item.entitySet.elementType.memberDefinitions\r\n                        .getPublicMappedProperties().forEach(function (memDef) {\r\n                            var typeName = Container.resolveName(memDef.type);\r\n                            if (memDef.key && memDef.computed && item.data[memDef.name] == undefined) {\r\n                                if (typeof self.supportedAutoincrementKeys[typeName] === 'function') {\r\n                                    var keyValue = self.supportedAutoincrementKeys[typeName]();\r\n                                    item.data[memDef.name] = self.fieldConverter.toDb[typeName](keyValue);\r\n                                } else {\r\n                                    // Autogenerated fields for new items should not be present in the physicalData\r\n                                    return;\r\n                                }\r\n                            }\r\n                            if (!memDef.inverseProperty && typeof memDef.concurrencyMode === 'undefined' && (memDef.key === true || item.data.entityState === $data.EntityState.Added || (item.data.changedProperties && item.data.changedProperties.some(function (def) { return def.name === memDef.name; })))) {\r\n                                if (self.fieldConverter.toDb[typeName]) {\r\n                                    item.physicalData[memDef.name] = self.fieldConverter.toDb[typeName](item.data[memDef.name]);\r\n                                } else {\r\n                                    var value = item.data[memDef.name];\r\n                                    if (value !== undefined) {\r\n                                        value = JSON.parse(JSON.stringify(value));\r\n                                    } \r\n                                    item.physicalData[memDef.name] = value;\r\n                                }\r\n                            }\r\n                        });\r\n                    return item;\r\n                });\r\n                var stores = [];\r\n                for (var i in storesObj) {\r\n                    stores.push(i);\r\n                }\r\n                var tran = self.db.transaction(stores, self.IDBTransactionType.READ_WRITE).setCallbacks({\r\n                    onerror: function (event) {\r\n                        // Only call the error callback when it's not because of an abort\r\n                        // aborted cases should call the error callback there\r\n                        if (!event.target || !self.IDBDatabaseException || (event.target && self.IDBDatabaseException && event.target.errorCode !== self.IDBDatabaseException.ABORT_ERR))\r\n                            callBack.error(event);\r\n                    },\r\n                    oncomplete: function (event) {\r\n                        // Moving to next block\r\n                        saveNextIndependentBlock();\r\n                    }\r\n                });\r\n                function KeySettingsCache() {\r\n                    /// <summary>\r\n                    /// Simple cache for key settings of types\r\n                    /// </summary>\r\n                    var cache = {};\r\n                    this.getSettingsForItem = function (item) {\r\n                        var typeName = item.data.getType().fullName;\r\n                        if (!cache.hasOwnProperty(typeName)) {\r\n                            cache[typeName] = self._getKeySettings(self.context._storageModel.getStorageModel(item.data.getType()));\r\n                        }\r\n                        return cache[typeName]\r\n                    }\r\n                }\r\n                var ksCache = new KeySettingsCache();\r\n                convertedItems.forEach(function (item) {\r\n                    // Getting store and keysettings for the current item\r\n                    var store = tran.objectStore(item.entitySet.tableName);\r\n                    var keySettings = ksCache.getSettingsForItem(item);\r\n                    // Contains the keys that should be passed for create, update and delete (composite keys)\r\n                    var itemKeys = keySettings.keys && keySettings.keys.map(function (key) { return item.physicalData[key]; }) || null;\r\n                    try {\r\n                        var cursorAction = function (action) {\r\n                            /// <summary>\r\n                            /// Find the current item in the store, and calls the action on it. Error raised when item was not found\r\n                            /// </summary>\r\n                            /// <param name=\"action\">Action to call on the item</param>\r\n                            var key = keySettings.keyPath ? item.physicalData[keySettings.keyPath] : itemKeys;\r\n                            var data = item.physicalData;\r\n                            store.openCursor(self.IDBKeyRange.only(key))\r\n                                .onsuccess = function (event) {\r\n                                    try {\r\n                                        var cursor = event.target.result;\r\n                                        if (cursor)\r\n                                            action(cursor, key, data);\r\n                                        else\r\n                                            Guard.raise(new Exception('Object not found', null, item));\r\n                                    } catch (ex) {\r\n                                        tran.abort();\r\n                                        callBack.error(ex);\r\n                                    }\r\n                                }\r\n                        };\r\n                        switch (item.data.entityState) {\r\n                            case $data.EntityState.Added:\r\n                                if (!keySettings.keyPath) {\r\n                                    // Item needs explicit keys\r\n                                    store.add(item.physicalData, itemKeys);\r\n                                }\r\n                                else {\r\n                                    store.add(item.physicalData)\r\n                                        .onsuccess = function (event) {\r\n                                            // Saves the generated key back to the entity\r\n                                            item.data[keySettings.keyPath] = event.target.result;\r\n                                        };\r\n                                }\r\n                                break;\r\n                            case $data.EntityState.Deleted:\r\n                                // Deletes the item\r\n                                cursorAction(function (cursor) {\r\n                                    cursor['delete']();\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Modified:\r\n                                // Updates the item\r\n                                cursorAction(function (cursor, key, data) {\r\n                                    cursor.update($data.typeSystem.extend(cursor.value, data));\r\n                                });\r\n                                break;\r\n                            case $data.EntityState.Unchanged:\r\n                                break;\r\n                            default:\r\n                                Guard.raise(new Exception('Not supported entity state', null, item));\r\n                        }\r\n                    } catch (ex) {\r\n                        // Abort on exceptions\r\n                        tran.abort();\r\n                        callBack.error(ex);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        saveNextIndependentBlock();\r\n    },\r\n    _compile: function (query) {\r\n        var sqlText = Container.createIndexedDBCompiler().compile(query);\r\n        return sqlText;\r\n    }\r\n}, {\r\n    isSupported: {\r\n        get: function () {\r\n            return $data.__global.indexedDB || $data.__global.webkitIndexedDB || $data.__global.mozIndexedDB || $data.__global.msIndexedDB ? true : false;\r\n        },\r\n        set: function () { }\r\n    }\r\n});\r\n\r\nif ($data.storageProviders.indexedDb.IndexedDBStorageProvider.isSupported)\r\n    $data.StorageProviderBase.registerProvider('indexedDb', $data.storageProviders.indexedDb.IndexedDBStorageProvider);\r\n","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _core = require('jaydata/core');\n\nvar _core2 = _interopRequireDefault(_core);\n\nvar _IndexedDBConverter = require('./IndexedDBConverter.js');\n\nvar _IndexedDBConverter2 = _interopRequireDefault(_IndexedDBConverter);\n\nvar _IndexedDBStorageProvider = require('./IndexedDBStorageProvider.js');\n\nvar _IndexedDBStorageProvider2 = _interopRequireDefault(_IndexedDBStorageProvider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _core2.default;\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbXX0="],"sourceRoot":"/source/"}